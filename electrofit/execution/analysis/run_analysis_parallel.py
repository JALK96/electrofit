#!/usr/bin/env python3
"""
run_analysis_discovery_parallel.py

Wie run_analysis_discovery.py, aber:
  - Refaktoriert, um cwd per subprocess.run zu übergeben
  - Sammelt alle Tasks und führt sie parallel aus via concurrent.futures
"""

import os
import re
import subprocess
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor, as_completed

##############################################################################
# USER CONFIGURATION 
##############################################################################

analysis_scripts = [
    "/home/johannal96/MA/electrofit/electrofit/execution/analysis/plot_dU_distributions_vertical.py __A__ __B__ --units kcal",
    "/home/johannal96/MA/electrofit/electrofit/execution/analysis/plot_dU_fwd_rev_consecutive.py __A__ __B__ --skip-time 300 --trim 0.1 --units kcal",
    "/home/johannal96/MA/electrofit/electrofit/execution/analysis/plot_energy_density_vertical.py __A__ __B__ --units kcal",
    "/home/johannal96/MA/electrofit/electrofit/execution/analysis/plot_dU_p_and_product.py __D__ --skip-time 300 --normalize --nsigma 6 --units kcal",
    "/home/johannal96/MA/electrofit/electrofit/execution/analysis/fep_analysis.py -i __D__ -o __O__ --temp 310 --units kcal/mol --skiptime 300",
    "/home/johannal96/MA/electrofit/electrofit/execution/analysis/breakdown_fep.py __C__", # must be listed below fep_analysis.py (__C__ must contain free_energy_summary.csv, that is generated by fep_analysis.py)
]


analysis_scripts = [
    "/home/johannal96/MA/electrofit/electrofit/execution/analysis/plot_energy_density_vertical.py __A__ __B__ --units kcal",
]

base_base_dirs = [
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/vacuum/011111-101111",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/vacuum/101111-111101",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/3ns/011111-101111",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/011111-101111",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/011111-111011",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/011111-111101",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/011111-111101_com_3ns",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/101111-111011_com_cos",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/101111-111101_com_cos",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/111011-111101_com_cos",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/neutral/A-A-B-B/A-A",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/neutral/A-A-B-B/A-B",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/neutral/A-A-B-B/B-B",
]

ANALYSE_RN_REGEX = r"^analyse_r(\d+)$"
WATER_SUBDIR_NAME = "water"
TRANSITIONS_SUBDIR = "transitions"

##############################################################################
# FUNKTIONSDEFINITIONEN (leicht angepasst)
##############################################################################

def run_command(cmd: str, cwd: Path):
    """Führt einen Shell-Befehl in Verzeichnis 'cwd' aus."""
    print(f"[{cwd.name}] Running: {cmd}")
    subprocess.run(cmd, shell=True, check=False, cwd=cwd)

def find_edges_or_workpath(base_dir: Path):
    results = []
    for name in ("edges", "workpath"):
        p = base_dir / name
        if p.is_dir():
            results.append(p)
    return results

def find_edge_dirs(sdir: Path):
    found = [e for e in sdir.glob("edge_*") if e.is_dir()]
    return found or [sdir]

def find_analyse_rN_dirs(edge_dir: Path):
    results = []
    for candidate in edge_dir.rglob("*"):
        if candidate.is_dir() and re.match(ANALYSE_RN_REGEX, candidate.name):
            run_num = re.match(ANALYSE_RN_REGEX, candidate.name).group(1)
            results.append((candidate, run_num))
    return results

def build_state_path(edge_dir: Path, st_name: str, run_num: str) -> Path:
    water_dir = edge_dir / WATER_SUBDIR_NAME
    if water_dir.is_dir():
        water_dir = water_dir / st_name
    else:
        water_dir = edge_dir / st_name

    run_dir = water_dir / f"run{run_num}"
    if run_dir.is_dir() and TRANSITIONS_SUBDIR:
        trans_dir = run_dir / TRANSITIONS_SUBDIR
        if trans_dir.is_dir():
            return trans_dir
    return run_dir

def run_analysis_in_directory(analysis_dir: Path, stateA_path: Path, stateB_path: Path):
    """
    Ersetzt os.chdir durch cwd in subprocess.run.
    Führt alle analysis_scripts in 'analysis_dir' aus.
    """
    A_str = str(stateA_path) if stateA_path.is_dir() else ""
    B_str = str(stateB_path) if stateB_path.is_dir() else ""
    base_label = analysis_dir.name

    for script in analysis_scripts:
        # Ersetze Platzhalter
        if "__A__" in script and "__B__" in script:
            cmd = script.replace("__A__", A_str).replace("__B__", B_str)
            run_command(f"python {cmd}", analysis_dir)

        elif "__D__" in script and "__O__" not in script:
            # Einzellauf pro Zustand
            if A_str:
                cmdA = script.replace("__D__", A_str)
                if "plot_dU_p_and_product.py" in script:
                    cmdA += f" --out_name plot_{base_label}_A.pdf"
                run_command(f"python {cmdA}", analysis_dir)
            if B_str:
                cmdB = script.replace("__D__", B_str)
                if "plot_dU_p_and_product.py" in script:
                    cmdB += f" --out_name plot_{base_label}_B.pdf"
                run_command(f"python {cmdB}", analysis_dir)

        elif "__D__" in script and "__O__" in script:
            # Mit __O__-Platzhalter
            if A_str:
                outA = str(analysis_dir / "stateA")
                cmdA = script.replace("__D__", A_str).replace("__O__", outA)
                run_command(f"python {cmdA}", analysis_dir)
            if B_str:
                outB = str(analysis_dir / "stateB")
                cmdB = script.replace("__D__", B_str).replace("__O__", outB)
                run_command(f"python {cmdB}", analysis_dir)

        elif "__C__" in script:
            # Sonderfall: Wechsle kurz ins Out-Verzeichnis
            if A_str:
                outA = analysis_dir / "stateA"
                cmdA = script.replace("__C__", str(outA))
                run_command(f"python {cmdA}", outA)
            if B_str:
                outB = analysis_dir / "stateB"
                cmdB = script.replace("__C__", str(outB)) + " --invert-ti"
                run_command(f"python {cmdB}", outB)
        else:
            print(f"[{analysis_dir.name}] Unknown placeholders in script: {script}")

def collect_tasks():
    """
    Scannt alle base_base_dirs und gibt eine Liste von Tasks zurück:
    [(analysis_dir, stateA_path, stateB_path), ...]
    """
    tasks = []
    for base_str in base_base_dirs:
        base = Path(base_str)
        if not base.is_dir():
            continue
        for sdir in find_edges_or_workpath(base):
            for edge_dir in find_edge_dirs(sdir):
                for (analysis_dir, run_num) in find_analyse_rN_dirs(edge_dir):
                    stateA = build_state_path(edge_dir, "stateA", run_num)
                    if not stateA.is_dir():
                        continue
                    stateB = build_state_path(edge_dir, "stateB", run_num)
                    tasks.append((analysis_dir, stateA, stateB))
    return tasks

def main():
    tasks = collect_tasks()
    print(f"Collected {len(tasks)} analysis tasks. Starte Parallel-Execution...")
    # Verwende so viele Threads wie CPU-Kerne (oder setze max_workers manuell)
    with ThreadPoolExecutor(max_workers=os.cpu_count() or 4) as executor:
        futures = {executor.submit(run_analysis_in_directory, d, A, B): (d, A, B)
                   for (d, A, B) in tasks}
        for future in as_completed(futures):
            d, A, B = futures[future]
            try:
                future.result()
            except Exception as e:
                print(f"[ERROR] Task {d} failed: {e}")

    print("=== Alle Analysen abgeschlossen! ===")

if __name__ == "__main__":
    main()