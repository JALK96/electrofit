#!/usr/bin/env python3
"""
run_fep_analysis_scripts.py

Automatically discovers:
  1) "edges/" or "workpath/" subdirectories under each base_base_dir
  2) "edge_*" or fallback
  3) "water" subdirectory, if present
  4) "analyse_rN" directories (with run number)
  5) "stateA"/"stateB" + "runN" + optional "transitions" subdir

Then:
  - cd into each analyse_rN folder so that script outputs go there.
  - run multiple commands from analysis_scripts, substituting placeholders:
       __A__ => path to stateA/runN/transitions
       __B__ => path to stateB/runN/transitions
       __D__ => single directory placeholder (runs once for A, once for B).

Usage:
  1) Make this file executable:
       chmod +x run_fep_analysis_scripts.py
  2) Edit base_base_dirs and analysis_scripts below.
  3) Run:
       ./run_fep_analysis_scripts.py
"""

import os
import re
import subprocess
from pathlib import Path

##############################################################################
# USER CONFIGURATION
##############################################################################

analysis_scripts = [
    "/home/johannal96/MA/electrofit/electrofit/execution/analysis/plot_dU_distributions_vertical.py __A__ __B__ --units kcal",
    "/home/johannal96/MA/electrofit/electrofit/execution/analysis/plot_dU_fwd_rev_consecutive.py __A__ __B__ --skip-time 300 --trim 0.1 --units kcal",
    "/home/johannal96/MA/electrofit/electrofit/execution/analysis/plot_energy_density_vertical.py __A__ __B__ --units kcal",
    "/home/johannal96/MA/electrofit/electrofit/execution/analysis/plot_dU_p_and_product.py __D__ --skip-time 300 --normalize --nsigma 6 --units kcal",
    "/home/johannal96/MA/electrofit/electrofit/execution/analysis/fep_analysis.py -i __D__ -o __O__ --temp 310 --units kcal/mol --skiptime 300",
    "/home/johannal96/MA/electrofit/electrofit/execution/analysis/breakdown_fep.py __C__", # must be listed below fep_analysis.py (__C__ must contain free_energy_summary.csv, that is generated by fep_analysis.py)
]


analysis_scripts = [
        "/home/johannal96/MA/electrofit/electrofit/execution/analysis/plot_dU_distributions_vertical.py __A__ __B__ --units kcal",
        "/home/johannal96/MA/electrofit/electrofit/execution/analysis/plot_dU_fwd_rev_consecutive.py __A__ __B__ --skip-time 300 --trim 0.1 --units kcal",
        "/home/johannal96/MA/electrofit/electrofit/execution/analysis/plot_energy_density_vertical.py __A__ __B__ --units kcal",
        "/home/johannal96/MA/electrofit/electrofit/execution/analysis/plot_dU_p_and_product.py __D__ --skip-time 300 --normalize --nsigma 6 --units kcal",
        "/home/johannal96/MA/electrofit/electrofit/execution/analysis/fep_analysis.py -i __D__ -o __O__ --temp 310 --units kcal/mol --skiptime 300", # --raw-only
        "/home/johannal96/MA/electrofit/electrofit/execution/analysis/breakdown_fep.py __C__", # must be listed below fep_analysis.py (__C__ must contain free_energy_summary.csv, that is generated by fep_analysis.py)
]


base_base_dirs = [
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/vacuum/011111-101111",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/vacuum/101111-111101",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/3ns/011111-101111",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/011111-101111",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/011111-111011",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/011111-111101",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/011111-111101_com_3ns",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/101111-111011_com_cos",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/101111-111101_com_cos",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/111011-111101_com_cos",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/neutral/A-A-B-B/A-A",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/neutral/A-A-B-B/A-B",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/neutral/A-A-B-B/B-B",
]

base_base_dirs = [
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/A-A-B-B/A-A",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/A-A-B-B/A-B",
    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/A-A-B-B/B-B",
]

## Problematic Directories: 
#    "/home/johannal96/MA/electrofit/FEP/equilibrium-FEP/neutral/A-A-B-B/B-B",


# Regex capturing run number from "analyse_rN"
ANALYSE_RN_REGEX = r"^analyse_r(\d+)$"

# We assume the directory layout has a "water" subdirectory that leads to:
# water/stateA/runN[/transitions] or water/stateB/runN[/transitions]
WATER_SUBDIR_NAME = "water"

# If you store transitions inside each run,
# set this to "transitions". If not, set empty string.
TRANSITIONS_SUBDIR = "transitions"

##############################################################################
# END OF USER CONFIGURATION
##############################################################################


def run_command(cmd: str):
    """Print and execute a shell command."""
    print(f"    Running: {cmd}")
    subprocess.run(cmd, shell=True, check=False)

def find_edges_or_workpath(base_dir: Path):
    """Return a list of subdirectories named 'edges' or 'workpath' under base_dir."""
    results = []
    edges = base_dir / "edges"
    workpath = base_dir / "workpath"
    if edges.is_dir():
        results.append(edges)
    if workpath.is_dir():
        results.append(workpath)
    return results

def find_edge_dirs(sdir: Path):
    """
    Return a list of 'edge_*' directories under sdir,
    or sdir itself if none found.
    """
    found = []
    has_edge = False
    for e in sdir.glob("edge_*"):
        if e.is_dir():
            has_edge = True
            found.append(e)
    if not has_edge:
        found.append(sdir)
    return found

def find_analyse_rN_dirs(parent: Path):
    """
    Recursively find subdirectories matching 'analyse_r(\d+)' (run number).
    We'll return a list of (analyse_dir, run_number).
    """
    results = []
    # The user places them typically under <edge_dir>/water/analyse_rN
    # But let's do a full rglob to be safe
    for candidate in parent.rglob("*"):
        if candidate.is_dir():
            match = re.match(ANALYSE_RN_REGEX, candidate.name)
            if match:
                run_num = match.group(1)  # e.g. '1' from 'analyse_r1'
                results.append((candidate, run_num))
    return results

def build_state_path(edge_dir: Path, st_name: str, run_num: str) -> Path:
    """
    Build the path to: edge_dir/water/st_name/run{run_num}[/transitions].
    Example: edge_011111_101111/water/stateA/run1/transitions
    """
    water_dir = edge_dir / WATER_SUBDIR_NAME
    if not water_dir.is_dir():
        # If there's no "water" subdir, fallback to edge_dir/st_name
        water_dir = edge_dir / st_name
        # But we return here or keep going
    else:
        # We do water_dir/st_name
        water_dir = water_dir / st_name

    run_dir = water_dir / f"run{run_num}"
    if not run_dir.is_dir():
        return run_dir  # might not exist at all

    if TRANSITIONS_SUBDIR:
        trans_dir = run_dir / TRANSITIONS_SUBDIR
        if trans_dir.is_dir():
            return trans_dir

    return run_dir

def run_analysis_in_directory(analysis_dir: Path, stateA_path: Path, stateB_path: Path):
    """
    cd into analysis_dir, then run each script from analysis_scripts,
    substituting placeholders:
      - __A__ => path to the stateA transitions
      - __B__ => path to the stateB transitions if available, else ""
      - __D__ => single directory usage, run once for A, once for B (if it exists).
    Additionally, if the script is 'plot_dU_p_and_product.py', we append '--out_name'
    with distinct filenames for stateA and stateB.
    """

    original_cwd = os.getcwd()
    try:
        os.chdir(str(analysis_dir))
        print(f"      cd into {analysis_dir}.")
    except FileNotFoundError:
        print(f"      Could not cd into {analysis_dir}, skipping.")
        return

    # We'll use analysis_dir.name to generate PDF filenames, for instance
    base_label = analysis_dir.name

    # Convert paths to strings for substitution
    A_str = str(stateA_path) if stateA_path.is_dir() else ""
    # If stateB_path does not exist, we map it to "", not skipping the entire script
    B_str = str(stateB_path) if stateB_path.is_dir() else ""

    for script in analysis_scripts:
        if "__A__" in script and "__B__" in script:
            # We do not skip if B is missing, but set B = ""
            cmd = script.replace("__A__", A_str).replace("__B__", B_str)
            print(f"    Running: python {cmd}")
            subprocess.run(f"python {cmd}", shell=True, check=False)

        elif "__D__" in script and "__O__" not in script:
            # Single-directory usage
            # We always run it once for stateA if A_str is not empty
            if A_str:
                cmdA = script.replace("__D__", A_str)
                if "plot_dU_p_and_product.py" in script:
                    outA = f"plot_dU_p_and_product_{base_label}_A.pdf"
                    cmdA += f" --out_name {outA}"
                print(f"    Running: python {cmdA}")
                subprocess.run(f"python {cmdA}", shell=True, check=False)

            # and once for stateB if B_str is not empty
            if B_str:
                cmdB = script.replace("__D__", B_str)
                if "plot_dU_p_and_product.py" in script:
                    outB = f"plot_dU_p_and_product_{base_label}_B.pdf"
                    cmdB += f" --out_name {outB}"
                print(f"    Running: python {cmdB}")
                subprocess.run(f"python {cmdB}", shell=True, check=False)

        elif "__D__" in script and "__O__" in script:
            if A_str:
                Out_A = str(analysis_dir / "stateA")
                cmdA = script.replace("__D__", A_str).replace("__O__", Out_A)
                print(f"    Running: python {cmdA}")
                subprocess.run(f"python {cmdA}", shell=True, check=False)

            # and once for stateB if B_str is not empty
            if B_str:
                Out_B = str(analysis_dir / "stateB")
                cmdB = script.replace("__D__", B_str).replace("__O__", Out_B)
                print(f"    Running: python {cmdB}")
                subprocess.run(f"python {cmdB}", shell=True, check=False)

        elif "__C__" in script:
            if A_str:
                Out_A = str(analysis_dir / "stateA")
                cmdA = script.replace("__C__", Out_A)
                print(f"    Change directory to: {Out_A}")
                os.chdir(Out_A)
                print(f"    Running: python {cmdA}")
                subprocess.run(f"python {cmdA}", shell=True, check=False)
                print(f"    Change directory back to: {str(analysis_dir)}")
                os.chdir(str(analysis_dir))

            # and once for stateB if B_str is not empty
            if B_str:
                Out_B = str(analysis_dir / "stateB")
                cmdB = script.replace("__C__", Out_B)
                cmdB += f" --invert-ti"
                print(f"    Change directory to: {Out_B}")
                os.chdir(Out_B)
                print(f"    Running: python {cmdB}")
                subprocess.run(f"python {cmdB}", shell=True, check=False)
                print(f"    Change directory back to: {str(analysis_dir)}")
                os.chdir(str(analysis_dir))

        else:
            print(f"      -> Script has unknown placeholders (neither __A__ nor __B__ nor __D__ nor __O__): {script}")

    os.chdir(original_cwd)

def main():
    for base_base_str in base_base_dirs:
        base_base = Path(base_base_str)
        if not base_base.is_dir():
            print(f"=== {base_base} not a directory, skipping... ===")
            continue

        print(f"\n=== Searching in: {base_base} ===")

        # 1) edges or workpath
        subdirs = find_edges_or_workpath(base_base)
        if not subdirs:
            print(f"  No edges/ or workpath/ found in {base_base}")
            continue

        for sdir in subdirs:
            if not sdir.is_dir():
                continue
            print(f"  -> Checking subdir: {sdir}")

            # 2) edge_* or fallback
            edirs = find_edge_dirs(sdir)
            if not edirs:
                print(f"    No edge_* found in {sdir}, skipping.")
                continue

            for edge_dir in edirs:
                if not edge_dir.is_dir():
                    continue
                print(f"    => Edge dir: {edge_dir}")

                # 3) find all "analyse_rN" subdirs
                analysis_list = find_analyse_rN_dirs(edge_dir)
                if not analysis_list:
                    print(f"      No analyse_rN subdirs in {edge_dir}.")
                    continue

                for (analysis_dir, run_num) in analysis_list:
                    print(f"\n      Found {analysis_dir} (N={run_num})")

                    # Build stateA path
                    stateA_path = build_state_path(edge_dir, "stateA", run_num)
                    if not stateA_path.is_dir():
                        print(f"      -> Missing stateA path: {stateA_path}, skipping.")
                        continue

                    # Build stateB path
                    stateB_path = build_state_path(edge_dir, "stateB", run_num)
                    # It's ok if stateB doesn't exist, the script will skip B or partial.

                    # Now run analysis in analysis_dir
                    run_analysis_in_directory(analysis_dir, stateA_path, stateB_path)

    print("\n=== Done. ===")

if __name__ == "__main__":
    main()